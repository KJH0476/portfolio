## 프로젝트 소개

해당 프로젝트는 **교보 DTS-Cloud architecture DX Academy(CDA) 1기 최종 프로젝트**로, **AWS 클라우드 서비스**를 활용한 **글로벌 식당 예약 플랫폼 인프라 구축**에 중점을 두고 있습니다.</br>
확장성과 안정성을 고려한 **Microservice Architecture(MSA)** 및 **ECS 기반 컨테이너 오케스트레이션**, **글로벌 CDN(CloudFront) 연동을 통한 사용자 경험 향상**, **성능 최적화 DB 선택**, **로그 및 에러 관리 자동화** 등을 통해 **트래픽 급증, 중복 예약 문제, 글로벌 확장성 요구**에 대응하고자 합니다.

---
## 프로젝트 개요

#### 배경

최근 흑백요리사와 같은 인기 프로그램이 큰 주목을 받으면서 식당 예약 애플리케이션에 트래픽이 집중되는 이슈를 보게 되었습니다. 이를 계기로, 트래픽 증가에도 유연하고 확장성 있는 예약 서비스를 제공할 수 있는 클라우드 기반 시스템을 구축해야겠다는 필요성을 느껴 이 프로젝트를 시작하게 되었습니다.

#### 목표

1. MSA(Microservice Architecture) 도입
	- 예약 및 검색 기능에 트래픽이 집중될 것으로 예상되므로 해당 기능을 독립적으로 확장하고 유지보수를 용이하게 하기 위해 MSA를 도입합니다.
2. 확장성과 유연성 보장
	- AWS ECS(Elastic Container Service) 기반 컨테이너 배포를 통해 자동 확장과 트래픽 급증에 유연한 대응이 가능하도록 설계합니다.
3. 성능 최적화
	- 서비스별 특성에 맞는 최적의 데이터베이스를 선택해 읽기/쓰기 성능을 극대화하도록 구성합니다.
4. 글로벌 사용자 경험 최적화
	- AWS CloudFront와 CloudFront Functions를 활용해 글로벌 사용자에게 지연 시간이 최소화된 콘텐츠를 제공하고, 가장 가까운 리전으로 요청을 리다이렉트하여 빠르고 안정적인 서비스 경험을 보장합니다.
5. 로그 수집 및 에러 로깅
	- 애플리케이션 로그를 수집해 추후 데이터 분석 기반을 마련하고, 에러 발생 시 Slack 알림 전송을 통해 신속한 문제 대응 체계를 구축합니다.

#### 기술 스택

- **프론트엔드:** React, JS, HTML, CSS
- **백엔드:** Spring Boot, Python, PostreSQL, Docker
- **배포:** Amazon Web Services
- **로그수집 및 에러로깅:** OpenSearch, Kibana, FluentBit
- **협업:** Jira, Github, Slack, Figma

---
## 담당

- Microservice Architecture 설계
- 데이터베이스 설계 및 구축
- AWS ECS 활용한 서비스 배포
- CloudFront Functions를 활용한 사용자 위치 기반 원본 리다이렉션

---
## 시스템 구성

![[architecture.png]]


---
## 구현 및 설계 상세 내용
### 1. 쓰기-읽기 분리를 통한 마이크로서비스 아키텍처 개선 및 CQRS 적용

프로젝트 초기에는 `예약 서비스`와 `검색 서비스`를 별도의 마이크로서비스로 구성하였고, 각 서비스마다 RDB를 두어 다음과 같은 역할을 갖도록 했습니다.

- **예약 서비스**
	- 사용자별 예약 정보, 예약 대기 리스트 관리 (쓰기 위주)
- **검색 서비스**
	- 식당 정보 및 식당별 예약 가능 시간대 관리 (주로 읽기, 그러나 예약 생성·취소 시 쓰기 작업 필요)

#### 초기 설계의 문제점

1. **서비스 간 높은 결합도**
	- 예약 생성 또는 취소 시, 예약 서비스가 검색 서비스의 API를 호출하여 해당 예약에 대한 식당별 예약 가능 시간의 자리를 증/감시키는 별도의 쓰기 작업을 수행해야 했습니다. 이는 예약 서비스와 검색 서비스 간의 의존도를 높였고, 시스템 복잡도를 증가시켰습니다.
2. **검색 서비스의 잦은 쓰기 작업 부담**
	- 본래 검색 서비스는 주로 읽기(조회) 요청에 최적화되어야 하나, 예약 관련 변경사항 반영을 위해 쓰기 작업이 빈번히 발생하였습니다. 이는 검색 성능과 확장성 측면에서 비효율적이었습니다.

![[cqrs_before.png]]

해당 문제 해결을 위해 **쓰기(Write)와 읽기(Read) 책임을 명확히 분리하는 방향**으로 아키텍처를 개선하였습니다.

#### 개선 방안

- **명확한 쓰기 책임 부여: 예약 서비스**
	- ==식당별 예약 가능 시간대 데이터==를 **예약 서비스로 이관**하여, 예약 생성·취소 등 모든 상태 변경 로직과 쓰기 작업을 예약 서비스 한 곳에서 처리하도록 하였습니다.
- **읽기 전용 역할 강화: 검색 서비스**
	- 검색 서비스에는 **식당의 기본 정보만 유지**하고, **OpenSearch 고성능 검색 솔루션을 활용**해 고급 조회 기능과 빠른 응답 속도를 제공하도록 하였습니다. 이로써 검색 서비스는 본래 목적에 집중하여 최적화된 읽기 전용 서비스로 기능하게 되었습니다.

![[cqrs_after.png]]

#### 결과

- **서비스 간 결합도 감소**
	- 예약 서비스 내에서 모든 쓰기 로직을 처리함으로써, 더 이상 예약 서비스와 검색 서비스 간의 API 호출을 통한 데이터 동기화가 필요 없어졌습니다.
- **읽기/쓰기 모델 분리 (CQRS 구현)**
	- 쓰기 모델(예약 서비스)과 읽기 모델(검색 서비스)을 분리함으로써 CQRS 패턴을 적용한 사례로 볼 수 있습니다. 이로써 각 서비스는 자신의 기능에 특화된 최적화 전략을 수립할 수 있었습니다.

> 💡 **CQRS(Command Query Responsibility Segregation)**</br>
> CQRS는 명령(Command, 쓰기)와 조회(Query, 읽기) 로직을 분리하는 패턴입니다.

### 2. AWS 기반 MSA 설계와 데이터베이스 최적화

해당 프로젝트의 서비스 특성상 **예약 기능과 검색 기능에 많은 트래픽이 몰릴 것으로 예상**하였고, **해당 서비스만 유연하게 확장하고 유지보수를 용이**하게 하기 위해 마이크로서비스 아키텍처를 도입하였습니다.</br>
또한, 분리된 각 서비스를 **독립된 컨테이너로 구성**하여 **AWS ECS**를 통해 배포 및 운영함으로써, 서비스의 확장성과 유연성을 확보하고 안정적인 운영을 구현하였습니다.

![[ecs_architecture.png]]

다음으로, 각 **서비스의 요구사항에 맞춰 최적의 데이터베이스를 선택**하여  **읽기/쓰기 성능을 최적화** 하였습니다.

| <center>**구분** | <center>**필요성**                                                       | <center>**선택 기술**   | <center>**선택 이유**                                           | 연결 서비스            |
| -------------- | --------------------------------------------------------------------- | ------------------- | ----------------------------------------------------------- | ----------------- |
| **회원 DB**      | 회원 정보는 스키마가 보다 명확하며 데이터 무결성이 매우 중요                                    | **AWS RDS**         | 데이터 무결성이 중요한 회원 정보를 안전하고 신뢰성 있게 관리하기 위해 AWS RDS 선택          | 회원 서비스            |
| **예약 DB**      | 예약 생성, 취소, 업데이트 등 쓰기 작업이 빈번하고 중복 예약과 오버부킹 방지를 위해 데이터 무결성 및 정합성이 매우 중요 | **AWS RDS**         | 예약 시 빈번한 쓰기 작업과 데이터 정합성을 보장하기 위해 트랜잭션이 가능한 AWS RDS 선택       | 예약 서비스            |
| **JWT 관리**     | 토큰 검증 및 조회 작업이 매우 빈번하며 토큰의 만료시간 관리가 필요                                | **AWS ElastiCache** | 메모리 기반 빠른 성능과 TTL(Time-to-Live) 기능을 제공하는 AWS ElastiCache 선택 | 회원 서비스, 인증/인가 서비스 |
| **검색 DB**      | 검색은 읽기 작업이 많고 빠른 응답이 필수적이며, 사용자가 다양한 조건으로 정확하고 빠른 검색을 원함              | **AWS OpenSearch**  | 빠른 읽기 성능과 고급 검색 기능 제공을 위해 AWS OpenSearch 선택                 | 검색 서비스            |

#### 초기 설계의 문제점

- 초기 설계에서는 식당 데이터를 OpenSearch에만 저장했기 때문에, **식당 정보를 업데이트하려면 OpenSearch에 직접 접근해야 했습니다.** 그러나 OpenSearch는 **빠른 검색과 분석**에는 최적화되어 있지만, **데이터 일관성**과 **장애 복구 기능**이 제한적이어서 **영구 저장소로 사용하기에는 부적합**했습니다.

![[search_service_opensearch.png]]

#### 개선 방안

- 이 문제를 개선하기 위해 **DynamoDB**를 영구 저장소로 선택하고, **DynamoDB Streams**와 **Lambda**를 활용해 변경된 데이터를 OpenSearch로 실시간 동기화하는 구조를 설계했습니다. 이를 통해 사용자에게 최신 데이터를 빠르게 제공하면서 데이터 이중화와 안정성을 동시에 확보했습니다.

![[dynamodb-lambda-opensearch.png]]

#### 결과

- **마이크로서비스 아키텍처 기반 확장성과 관리 효율성 확보**
	- 예약, 검색, 인증/인가, 회원, 알림 서비스 등 5개의 마이크로서비스를 AWS ECS Fargate에 각각 독립된 컨테이너로 배포하여 각 서비스가 개별적으로 확장 및 관리되도록 설계했습니다.
- **데이터 이중화 및 실시간 동기화 구현**
	- DynamoDB를 영구 저장소로 사용하고, DynamoDB Streams와 Lambda를 통해 OpenSearch와 실시간 동기화를 구현함으로써, 데이터 이중화와 안정성을 확보하고 최신 데이터를 빠르게 제공할 수 있는 시스템을 구축했습니다.

### 3. CloudFront Functions를 활용한 사용자 위치 기반 리다이렉션

글로벌 사용자에게 서비스를 제공하기 위해, 사용자가 접속한 위치에 따라 가장 가까운 리전으로 트래픽을 유도하는 것은 **성능 최적화**와 **사용자 경험(UX) 향상**에 중요한 부분이었습니다. 이를 실현하기 위해 다음과 같은 3가지 선택지를 검토하였습니다.

| 서비스                      | 장점                                                           | 단점                                                                                                                                      |
| ------------------------ | ------------------------------------------------------------ | --------------------------------------------------------------------------------------------------------------------------------------- |
| **Route53 지리적 라우팅**      | DNS 레벨에서 지리적 라우팅을 손쉽게 구성할 수 있어 초기 설정이 간단                     | 사용자가 특정 리전을 선택할 때 프론트엔드에 별도 도메인 관리 로직이 필요하여 유지보수 및 개발 복잡도가 증가함                                                                          |
| **CloudFront Functions** | 엣지 레벨에서 국가별 리다이렉션을 가볍고 빠르게 처리할 수 있어 프론트엔드 복잡도를 낮추고 지연시간을 최소화 | Lambda@Edge보다 기능 범위가 제한되어 복잡한 로직 구현에는 제약사항                                                                                              |
| **Lambda@Edge**          | 엣지 레벨에서 복잡한 로직을 구현할 수 있어 다양한 요청 변환 및 고급 처리에 유연               | CloudFront Functions 대비 무겁고 비용, 지연시간이 증가하기 때문에 단순한 국가별 라우팅에는 과도한 선택일 수 있음<br>---<br>요금(요청 백만 회당): CF Functions \$0.1, Lambda@Edge \$0.6 |

#### 최종 선택

이러한 비교를 바탕으로, **CloudFront Functions**를 도입했습니다. CloudFront Functions는 요청 시 사용자 국가 코드를 확인해 해당 국가에 가장 가까운 리전으로 즉시 리다이렉트하는 경량 서버리스 기능입니다. 이를 통해 프론트엔드 측 수정 부담을 크게 줄이면서 국가별 라우팅을 구현할 수 있었고, 단순한 로직으로도 글로벌 사용자 경험을 개선할 수 있었습니다.

#### 도입 효과

1. **사용자 위치 기반 자동 라우팅**
	- CloudFront의 `cloudfront-viewer-country` 헤더를 활용하여 **사용자의 접속 국가를 판단**하고, 해당 국가에 맞는 **최적의 리전으로 자동 라우팅**하는 로직을 구현하였습니다.
	- 사용자가 다른 국가의 리전을 선택하는 경우 `x-region` 헤더에 선택한 국가의 국가 코드값을 설정하고 `x-region`에 값이 설정되어 있는 경우 해당 값을 우선 적용하여 사용자가 원하는 국가 리전의 서비스를 이용할 수 있도록 해주었습니다.

![[cf_functions_logic.png]]

2. **지연 시간 최소화**
	- **사용자가 인접한 리전으로 즉각 연결**되므로, 네트워크 왕복 지연이 감소하여 응답 속도가 빨라졌고, 전반적인 사용자 경험이 향상되었습니다.
</br></br>
3. **운영 관리 비용 절감**
	- 새로운 리전을 추가하거나 기존 라우팅 정책을 조정할 때도 CloudFront Functions 스크립트만 수정하면 되므로, 글로벌 서비스 확장 시 발생하는 관리 부담이 크게 줄어들었습니다.

#### 결과

- **CloudFront Functions**를 적용했을때 멀티 리전 아키텍처입니다. 사용자가 API 요청을 보내면 **CloudFront Functions 스크립트**가 실행되어 **사용자와 가장 가까운 리전의 ALB(Application Load Balancer)** 또는 **사용자가 선택한 리전의 ALB**로 요청을 리다이렉트합니다.
![[cloudfront_architecture.png]]

- 드롭다운 메뉴에서 미국(버지니아 북부) 리전 선택시 미국 식당이 검색되는 것을 확인할 수 있습니다.
![[us_page.png]]

---
## 결과 및 성과

- **확장 가능하고 안정적인 서비스 구축**
	- 서비스를 MSA 로 설계하고 AWS ECS로 배포함으로써 보다 유연하게 확장 가능하고 안정적인 서비스 환경을 조성했습니다.
- **글로벌 사용자 대상 지연 시간 최소화**
	- CloudFront Functions로 사용자 위치 기반 리다이렉션을 구현해 가장 가까운 리전으로 트래픽을 유도하여 응답 속도와 서비스 가용성을 향상시켰습니다.
- **데이터 일관성과 운영 효율성 확보**
	- DynamoDB Streams - Lambda - OpenSearch 구조로 데이터 변경의 실시간 반영과 자동 데이터 동기화를 구현했습니다.

---
### 🔗 Link
- [[content/index|Home]]
- 정리 문서
	- [[글로벌 서비스 아키텍처 고려사항]]
	- [[ECS 배포 중 에러 발생 및 해결]]
	- [[UnsupportedOperationException 에러 발생 및 해결]]