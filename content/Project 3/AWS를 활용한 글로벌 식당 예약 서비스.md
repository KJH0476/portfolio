## 프로젝트 소개

해당 프로젝트는 **교보 DTS-Cloud architecture DX Academy(CDA) 1기 최종 프로젝트**로, **AWS 클라우드 서비스**를 활용한 **글로벌 식당 예약 플랫폼 인프라 구축**에 중점을 두고 있습니다.
확장성과 안정성을 고려한 **Microservice Architecture(MSA)** 및 **ECS 기반 컨테이너 오케스트레이션**, **글로벌 CDN(CloudFront) 연동을 통한 사용자 경험 향상**, **성능 최적화 DB 선택**, **로그 및 에러 관리 자동화** 등을 통해 **트래픽 급증, 중복 예약 문제, 글로벌 확장성 요구**에 대응하고자 합니다.

---
## 프로젝트 개요

#### 배경

최근 흑백요리사와 같은 인기 프로그램이 큰 주목을 받으면서 식당 예약 애플리케이션에 트래픽이 집중되는 이슈를 보게 되었습니다. 이를 계기로, 트래픽 증가에도 유연하고 확장성 있는 예약 서비스를 제공할 수 있는 클라우드 기반 시스템을 구축해야겠다는 필요성을 느껴 이 프로젝트를 시작하게 되었습니다.

#### 목표
1. MSA(Microservice Architecture) 도입
	- 예약 및 검색 기능에 트래픽이 집중될 것으로 예상되므로 해당 기능을 독립적으로 확장하고 유지보수를 용이하게 하기 위해 MSA를 도입합니다.
2. 확장성과 유연성 보장
	- AWS ECS(Elastic Container Service) 기반 컨테이너 배포를 통해 자동 확장과 트래픽 급증에 유연한 대응이 가능하도록 설계합니다.
3. 성능 최적화
	- 서비스별 특성에 맞는 최적의 데이터베이스를 선택해 읽기/쓰기 성능을 극대화하도록 구성합니다.
4. 글로벌 사용자 경험 최적화
	- AWS CloudFront와 CloudFront Functions를 활용해 글로벌 사용자에게 지연 시간이 최소화된 콘텐츠를 제공하고, 가장 가까운 리전으로 요청을 리다이렉트하여 빠르고 안정적인 서비스 경험을 보장합니다.
5. 로그 수집 및 에러 로깅
	- 애플리케이션 로그를 수집해 추후 데이터 분석 기반을 마련하고, 에러 발생 시 Slack 알림 전송을 통해 신속한 문제 대응 체계를 구축합니다.

#### 기술 스택
| <center>분류</center> | <center>기술 스택</center>                                                                                                                                                                                                                                                                                                                                                                                                                       |
| ------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 프론트엔드               | <img src="https://img.shields.io/badge/React-61DAFB?style=flat&logo=React&logoColor=white"/> <img src="https://img.shields.io/badge/JavaScript-ES6+-F7DF1E?style=flat&logo=JavaScript&logoColor=yellow"/> <img src="https://img.shields.io/badge/HTML5-E34F26?style=flat&logo=HTML5&logoColor=white"/> <img src="https://img.shields.io/badge/CSS3-1572B6?style=flat&logo=CSS3&logoColor=white"/>                                            |
| **백엔드**             | <img src="https://img.shields.io/badge/Spring%20Boot-6DB33F?style=flat&logo=Spring%20Boot&logoColor=white"/> <img src="https://img.shields.io/badge/Python-3776AB?style=flat&logo=Python&logoColor=white" alt="Python"> <img src="https://img.shields.io/badge/PostgreSQL-336791?style=flat&logo=PostgreSQL&logoColor=white" alt="PostgreSQL"> <img src="https://img.shields.io/badge/Docker-2496ED?style=flat&logo=docker&logoColor=white"> |
| **배포**              | <img src="https://img.shields.io/badge/Amazon Web Services-232F3E?style=flat&logo=amazonwebservices&logoColor=white">                                                                                                                                                                                                                                                                                                                        |
| 로그수집 및 에러로깅         | <img src="https://img.shields.io/badge/AWS OpenSearch-005EB8?style=flat&logo=OpenSearch&logoColor=white" alt="OpenSearch"> <img src="https://img.shields.io/badge/Kibana-005571?style=flat&logo=Kibana&logoColor=white" alt="Kibana"> <img src="https://img.shields.io/badge/Fluent Bit-49BDA5?style=flat&logo=Fluent%20Bit&logoColor=white" alt="Fluent Bit">                                                                               |
| 협업                  | <img src="https://img.shields.io/badge/Jira-0052CC?style=flat&logo=jira&logoColor=white"> <img src="https://img.shields.io/badge/GitHub-181717?style=flat&logo=github&logoColor=white"> <img src="https://img.shields.io/badge/Slack-4A154B?style=flat&logo=slack&logoColor=white"> <img src="https://img.shields.io/badge/Figma-F24E1E?style=flat&logo=Figma&logoColor=white" alt="Figma">                                                  |

---
## 구현 및 설계 상세 내용
### 1. 쓰기-읽기 분리를 통한 마이크로서비스 아키텍처 개선 및 CQRS 적용

프로젝트 초기에는 `예약 서비스`와 `검색 서비스`를 별도의 마이크로서비스로 구성하였고, 각 서비스마다 RDB를 두어 다음과 같은 역할을 갖도록 했습니다.

- **예약 서비스**
	- 사용자별 예약 정보, 예약 대기 리스트 관리 (쓰기 위주)
- **검색 서비스**
	- 식당 정보 및 식당별 예약 가능 시간대 관리 (주로 읽기, 그러나 예약 생성·취소 시 쓰기 작업 필요)

#### 초기 설계의 문제점

1. **서비스 간 높은 결합도**
	- 예약 생성 또는 취소 시, 예약 서비스가 검색 서비스의 API를 호출하여 해당 예약에 대한 식당별 예약 가능 시간의 자리를 증/감시키는 별도의 쓰기 작업을 수행해야 했습니다. 이는 예약 서비스와 검색 서비스 간의 의존도를 높였고, 시스템 복잡도를 증가시켰습니다.
2. **검색 서비스의 잦은 쓰기 작업 부담**
	- 본래 검색 서비스는 주로 읽기(조회) 요청에 최적화되어야 하나, 예약 관련 변경사항 반영을 위해 쓰기 작업이 빈번히 발생하였습니다. 이는 검색 성능과 확장성 측면에서 비효율적이었습니다.
![[cqrs_before.png]]

해당 문제 해결을 위해 **쓰기(Write)와 읽기(Read) 책임을 명확히 분리하는 방향**으로 아키텍처를 개선하였습니다.

#### 개선 사항

- **명확한 쓰기 책임 부여: 예약 서비스**
	- <span style="background:#9254de"><span style="background:rgba(136, 49, 204, 0.2)">식당별 예약 가능 시간대 데이터</span></span>를 **예약 서비스로 이관**하여, 예약 생성·취소 등 모든 상태 변경 로직과 쓰기 작업을 예약 서비스 한 곳에서 처리하도록 하였습니다.
- **읽기 전용 역할 강화: 검색 서비스**
	- 검색 서비스에는 **식당의 기본 정보만 유지**하고, **OpenSearch 고성능 검색 솔루션을 활용**해 고급 조회 기능과 빠른 응답 속도를 제공하도록 하였습니다. 이로써 검색 서비스는 본래 목적에 집중하여 최적화된 읽기 전용 서비스로 기능하게 되었습니다.
![[cqrs_after.png]]

#### 결과

- **서비스 간 결합도 감소**
	- 예약 서비스 내에서 모든 쓰기 로직을 처리함으로써, 더 이상 예약 서비스와 검색 서비스 간의 API 호출을 통한 데이터 동기화가 필요 없어졌습니다.
- **읽기/쓰기 모델 분리 (CQRS 구현)**
	- 쓰기 모델(예약 서비스)과 읽기 모델(검색 서비스)을 분리함으로써 CQRS 패턴을 적용한 사례로 볼 수 있습니다. 이로써 각 서비스는 자신의 기능에 특화된 최적화 전략을 수립할 수 있었습니다.

> 💡 **CQRS(Command Query Responsibility Segregation)**</br>
> CQRS는 명령(Command, 쓰기)와 조회(Query, 읽기) 로직을 분리하는 패턴입니다.

### 2. 마이크로 서비스 아키텍처 설계 및 AWS ECS(Elastic Container Service)로 서비스 배포

해당 프로젝트의 서비스 특성상 **예약 기능과 검색 기능에 많은 트래픽이 몰릴 것으로 예상**하였고, **해당 서비스만 유연하게 확장하고 유지보수를 용이**하게 하기 위해 마이크로서비스 아키텍처를 도입하였습니다.
또한, 분리된 각 서비스를 **독립된 컨테이너로 구성**하여 **AWS ECS**를 통해 배포 및 운영함으로써, 서비스의 확장성과 유연성을 확보하고 안정적인 운영을 구현하였습니다.

#### 구현 내용

1. **MSA 서비스 구성 및 AWS Fargate를 활용한 서비스 배포**

인증/인가 서비스, 회원 서비스, 예약 서비스, 알림 서비스, 검색 서비스 등 **5개의 마이크로서비스**를 각각 **독립된 컨테이너 이미지**로 패키징하여 **AWS ECS**를 사용해 서비스를 배포하였습니다.
모든 요청은 인증/인가 서비스를 거친 뒤, 적합한 백엔드 서비스로 전달되며, 인증/인가 서비스는 JWT 토큰 검증과 요청 라우팅을 담당합니다.
**AWS Fargate** 시작 유형을 사용하여 서버 관리 부담 없이 확장성을 확보했으며, 인기 트렌드나 이벤트로 인해 트래픽이 급증할 경우에도 오토스케일링을 통해 각 서비스가 빠르게 확장(Scale-out)될 수 있도록 설정했습니다. 이러한 설계로 각 서비스는 인증된 요청에만 집중하며 효율적으로 동작할 수 있었습니다.

![[msa_architecture.png]]


2. **서비스별 데이터베이스 선택 및 설계**

각 서비스의 요구사항에 맞춰 최적의 데이터베이스를 선택하여  읽기/쓰기 성능을 최적화 하였습니다.

| <center>**구분** | <center>**필요성**                                                       | <center>**선택 기술**   | <center>**선택 이유**                                           |
| -------------- | --------------------------------------------------------------------- | ------------------- | ----------------------------------------------------------- |
| **회원 DB**      | 회원 정보는 스키마가 보다 명확하며 데이터 무결성이 매우 중요                                    | **AWS RDS**         | 데이터 무결성이 중요한 회원 정보를 안전하고 신뢰성 있게 관리하기 위해 AWS RDS 선택          |
| **예약 DB**      | 예약 생성, 취소, 업데이트 등 쓰기 작업이 빈번하고 중복 예약과 오버부킹 방지를 위해 데이터 무결성 및 정합성이 매우 중요 | **AWS RDS**         | 예약 시 빈번한 쓰기 작업과 데이터 정합성을 보장하기 위해 트랜잭션이 가능한 AWS RDS 선택       |
| **JWT 관리**     | 토큰 검증 및 조회 작업이 매우 빈번하며 토큰의 만료시간 관리가 필요                                | **AWS ElastiCache** | 메모리 기반 빠른 성능과 TTL(Time-to-Live) 기능을 제공하는 AWS ElastiCache 선택 |
| **검색 DB**      | 검색은 읽기 작업이 많고 빠른 응답이 필수적이며, 사용자가 다양한 조건으로 정확하고 빠른 검색을 원함              | **AWS OpenSearch**  | 빠른 읽기 성능과 고급 검색 기능 제공을 위해 AWS OpenSearch 선택                 |

**초기 설계의 문제점**
- OpenSearch는 빠른 검색과 분석에 최적화된 시스템이지만, **데이터 일관성**과 **장애 복구 기능**이 제한적이어서 영구 저장소로 사용하기엔 부적합했습니다.

**해결 방안**
- 이 문제를 해결하기 위해 **DynamoDB**를 영구 저장소로 선택하고, **DynamoDB Streams**와 **Lambda**를 활용해 변경된 데이터를 OpenSearch로 실시간 동기화하는 구조를 설계했습니다. 이를 통해 사용자에게 최신 데이터를 빠르게 제공하면서 데이터 이중화와 안정성을 동시에 확보했습니다.
![[dynamodb-lambda-opensearch.png]]

#### 결과

- 단일 리전 아키텍처
	- Private Subnet에 
	![[architecture.png]]

### 3. CloudFront Functions를 활용한 사용자 위치 기반 리다이렉션

글로벌 사용자에게 서비스를 제공하는 과정에서, 사용자가 접속한 위치에 따라 가장 가까운 리전으로 트래픽을 유도하는 것은 **성능 최적화**와 **사용자 경험(UX) 향상**의 핵심 과제였습니다. 이를 달성하기 위해 다음과 같은 3가지 선택지를 검토하였습니다.

| 서비스                      | 장점                                                           | 단점                                                                                                                                    |
| ------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------- |
| **Route53 지리적 라우팅**      | DNS 레벨에서 지리적 라우팅을 손쉽게 구성할 수 있어 초기 설정이 간단                     | 사용자가 특정 리전을 선택할 때 프론트엔드에 별도 도메인 관리 로직이 필요하여 유지보수 및 개발 복잡도가                                                                            |
| **CloudFront Functions** | 엣지 레벨에서 국가별 리다이렉션을 가볍고 빠르게 처리할 수 있어 프론트엔드 복잡도를 낮추고 지연시간을 최소화 | Lambda@Edge보다 기능 범위가 제한되어 복잡한 로직 구현에는 제약사항                                                                                            |
| **Lambda@Edge**          | 엣지 레벨에서 복잡한 로직을 구현할 수 있어 다양한 요청 변환 및 고급 처리에 유연               | CloudFront Functions 대비 무겁고 비용, 지연시간이 증가하기 때문에 단순한 국가별 라우팅에는 과도한 선택일 수 있음<br>---<br>요금(요청 백만 회당): CF Functions $0.1, Lambda@Edge $0.6 |

#### 최종 선택

이러한 비교를 바탕으로, **CloudFront Functions**를 도입했습니다. CloudFront Functions는 요청 시 사용자 국가 코드를 확인해 해당 국가에 가장 가까운 리전으로 즉시 리다이렉트하는 경량 서버리스 기능입니다. 이를 통해 프론트엔드 측 수정 부담을 크게 줄이면서 국가별 라우팅을 구현할 수 있었고, 단순한 로직으로도 글로벌 사용자 경험을 개선할 수 있었습니다.

#### 도입 효과 ==> ==이부분도 수정 필요 내용 전체적으로 수정하고 운영적인 이점 강조==

1. **사용자 위치 기반 자동 라우팅**
	- CloudFront의 `cloudfront-viewer-country` 헤더를 활용하여 **사용자의 접속 국가를 판단**하고, 해당 국가에 맞는 **최적의 리전으로 자동 라우팅**하는 로직을 구현하였습니다.
	- 사용자가 다른 국가의 리전을 선택하는 경우 `x-region` 헤더에 선택한 국가의 국가 코드값을 설정하고 `x-region`에 값이 설정되어 있는 경우 해당 값을 우선 적용하여 사용자가 원하는 국가 리전의 서비스를 이용할 수 있도록 해주었습니다.
![[cf_functions_logic.png]]

2. **프론트엔드 복잡도 감소**
	- CloudFront Functions가 엣지 레벨에서 동적으로 리다이렉트하기 때문에, 프론트엔드 개발 부담과 코드 복잡도가 크게 낮아졌습니다.

3. **지연 시간 최소화
	- **사용자가 인접한 리전으로 즉각 연결**되므로, 네트워크 왕복 지연이 감소하여 응답 속도가 빨라졌고, 전반적인 사용자 경험이 향상되었습니다.

4. **유연한 확장성 확보**
	- 새로운 리전을 추가하거나 기존 라우팅 정책을 조정할 때도 CloudFront Functions 스크립트만 수정하면 되므로, 글로벌 서비스 확장 시 발생하는 관리 부담이 크게 줄어들었습니다.

#### 결과

- CloudFront Functions 적용한 멀티리전 인프라 구축 다이어그램
![[cloudfront_architecture.png]]

- 드롭다운 메뉴에서 미국(버지니아 북부) 리전 선택시 미국 식당이 검색됨
![[us_page.png]]

---
## 결과 및 성과
- 프로젝트 최종 결과물에 대한 소개(데모 링크, 배포 URL, 동영상)
- 서비스 런칭 이후의 반응(사용자 수, 피드백, 개선점)
- 개인적으로 얻은 경험치 (개발 역량 향상, 기술 스택 확장 등)

---
### 🔗 Link
- [[content/index|Home]]
- 정리 문서
	- [[글로벌 서비스 아키텍처 고려사항]]
	- [[ECS 배포 중 에러 발생 및 해결]]
	- [[UnsupportedOperationException 에러 발생 및 해결]]