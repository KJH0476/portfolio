## 📄 목차
- [프로젝트 개요](#프로젝트-개요)
- [주요 기능](#주요-기능)
- [기술 스택 및 아키텍처](#기술-스택-및-아키텍처)
- [문제 해결 경험](#문제-해결-경험)
- [결과 및 성과](#결과-및-성과)
- [Link](#-Link)
---
## 프로젝트 개요

> 💡 **TIL 챌린지란?**</br>
> 매주 `TIL N월 N주차`라는 메시지를 슬랙(Slack)에 게시하면, 멤버들은 해당 메시지에 답글로 자신이 작성한 블로그 글의 URL을 올립니다. 다른 사용자들은 해당 글을 읽고, 마음에 들면 좋아요(👍)를 눌러 서로의 학습 내용을 격려하고 공유합니다.

**목적**
- Slack 기반의 TIL(오늘 배운 것) 챌린지를 자동화하고 시각화하기 위한 챗봇 및 대시보드 개발

**배경**
- Slack 기반 TIL 챌린지에서는 새 답글이 등록될 때, 해당 글에 참여한 일부 멤버만 알림을 받고, 챌린지에 참여하지 않은 멤버들은 새로운 학습 내용이 게시된 사실을 알 수 없었습니다. 이로 인해 ‘서로의 학습 내용을 공유한다’는 챌린지의 본래 취지를 살리지 못한다고 판단하여, 본 프로젝트를 시작하게 되었습니다.
- 기존에는 매니저님이 매주 수동으로 `TIL N월 N주차` 글을 올리고, 참여 현황과 좋아요(👍) 수를 직접 집계하는 등 비효율적인 관리 방식으로 진행되었습니다.

**개선점**
- 매주 `TIL N월 N주차` 메시지를 자동 게시
- 신규 참여 답글 발생 시 채널 전체 알림 발송
- 좋아요(👍) 수 및 주차별 참여 통계 자동 집계 및 웹 대시보드 제공
- 매월 챌린저(모든 주 참여 + 최고 좋아요 수) 자동 선정 및 결과 게시

## 주요 기능

1. **TIL 챌린지 자동 게시 및 알림**  
   - 매주 월요일 `TIL N월 N주차` 메시지를 Slack 채널에 자동으로 게시  
	![[main-img2.png]]
   - 멤버가 블로그 URL을 첨부한 답글을 달면 전체 채널에 알림 메시지 발송 (핵심 자동화 기능 구현)
	![[main-img1.png]]
2. **좋아요(👍) 집계 자동화**  
   - TIL 챌린지 게시글의 답글에 달린 👍 이 추가/삭제될 때마다 해당 멤버의 좋아요 수를 실시간 집계
   - 좋아요 반영 시 Velog, Github, Naver 블로그 링크 여부 체크를 통해 실제 참여여부를 정확히 관리
3. **월별 챌린저 선정 자동화**  
   - 매월 첫 번째 월요일에 지난달 전 주차에 참여한 멤버 및 그 중 최고 좋아요 획득자를 자동 선정 및 발표
	![[main-img3.png]]
4. **시각화 대시보드 제공**  
   - S3에 저장된 JSON 데이터를 React 기반 정적 웹으로 시각화
   - 주차별 참여 인원 및 좋아요 수를 한눈에 확인 가능
	![[dashboard.png]]
5. **Slack 개인 DM 알림**  
   - 좋아요 변동 시 본인 DM으로 상태 메시지 전송
   - 에러 발생 시 에러 알림 메시지 전송

## 기술 스택 및 아키텍처

- **사용 기술**
	 <img src="https://img.shields.io/badge/python-3776AB?style=&logo=python&logoColor=white"> <img src="https://img.shields.io/badge/slack api-4A154B?style=&logo=slack&logoColor=white"> <img src="https://img.shields.io/badge/aws-232F3E?style=&logo=amazonwebservices&logoColor=white"> <img src="https://img.shields.io/badge/aws lambda-FF9900?style=&logo=awslambda&logoColor=white"> <img src="https://img.shields.io/badge/aws s3-569A31?style=&logo=amazons3&logoColor=white"> <img src="https://img.shields.io/badge/aws sqs-FF4F8B?style=&logo=amazonsqs&logoColor=white"> <img src="https://img.shields.io/badge/react-61DAFB?style=&logo=react&logoColor=white">
- **아키텍처**
	![[til-architecture.png]]
	 - **서버리스 아키텍처(AWS Lambda) 선택 이유**: 빠른 배포, 관리 부담 감소, 사용량 기반 과금
	 - **S3 사용 이유**: 소규모 JSON 데이터 관리에 적합, 단순 구조 유지
	 - **SQS 도입**: FIFO 큐로 요청 직렬 처리 → 동시성 문제 해결, 데이터 무결성 보장  

## 문제 해결 경험
### 문제 1 - S3 동시성 문제
초기에는 `API Gateway → Lambda → S3` 구조로 요청을 처리했습니다. 또한, 챌린지 참여자 수가 10명 내외로 많지 않아 간단히 S3에 JSON 형태로 데이터를 저장하고 읽는 방식이었습니다. 그러나 S3에는 파일 잠금(파일 락) 기능이 없어, 여러 사용자가 동시에 데이터를 읽고 쓰는 상황에서 데이터 무결성이 깨질 수 있었습니다.
예를 들어, A와 B가 동시에 챌린지에 참여하는 글을 남길 때, Lambda는 동일한 S3 JSON 파일을 불러와 각각의 참여 정보를 추가합니다. A가 먼저 S3에 데이터를 반영하고 저장한 직후, B도 이전 상태의 S3 데이터를 기반으로 다시 저장하려 하면 A의 변경 사항이 덮어쓰여져 데이터에 반영되지 않을 수 있습니다.

>[!note] 개선 방법: SQS(FIFO) 도입
> 이 문제를 해결하기 위해 **AWS SQS의 FIFO 큐**를 도입했습니다. 새로운 구조는 다음과 같습니다.
> ![[main-img4.png]]
> 이제 모든 요청은 먼저 SQS에 적재되며, FIFO 큐 특성상 메시지를 순서대로 하나씩 Lambda 함수에 전달합니다. 또한, SQS 트리거 설정 시 배치 처리 수를 1로 지정하여 Lambda가 오직 하나의 요청만 순차적으로 처리하도록 했습니다. 이로써 S3 접근 시 모든 이전 요청 처리가 완료된 상태를 보장하여, 동시에 발생할 수 있는 덮어쓰기 문제를 근본적으로 방지하고 S3 데이터의 무결성을 확보할 수 있었습니다.

### 문제 2 - Slack 이벤트 URL 검증(Challenge 요청) 문제
![[img3.png]]
Slack 이벤트를 구독하려면 Slack에서 제공하는 **Challenge 요청에 응답**해야 합니다. 이때 Slack은 `challenge`라는 키를 포함한 값을 보내며, 서버는 해당 `challenge` 값을 그대로 반환해야 이벤트 구독을 인정받습니다.
하지만 기존 구조(`API Gateway → SQS → Lambda`)에서는 Slack이 원하는 즉각적인 응답을 제공하기 어려웠습니다. Slack이 `challenge` 요청을 보내면, API Gateway는 이를 SQS에 전달하고, SQS는 메시지 큐에 성공적으로 저장했다는 응답을 API Gateway로 보내는 식으로 비동기로 동작하기 때문입니다.
그 결과 Slack에게는 `challenge` 값 대신 SQS 처리 성공 정보가 먼저 반환되어버리고, Slack은 URL 검증에 실패하게 됩니다. Lambda가 나중에 `challenge` 값을 보내도 이미 검증 요청은 끝난 상태입니다.

> [!note] 개선 방법: Challenge 처리 전용 Lambda 추가
> 이 문제를 해결하기 위해 Challenge 요청에 대해서만 즉시 응답 가능한 구조를 도입했습니다. SQS로 보내기 전 **Challenge 요청 전용 Lambda 함수를 추가**하여, 이 Lambda에서 Slack의 `challenge` 값을 즉시 반환하도록 했습니다. 이렇게 하면 Slack이 바로 원하는 응답을 얻을 수 있어 이벤트 구독이 정상적으로 완료됩니다.
> 이후 일반 이벤트 요청은 기존대로 SQS를 통해 비동기적으로 처리하면 됩니다. 이를 통해 Slack 이벤트 URL 검증에 실패하는 문제를 해결했습니다.
> ![[main-img5.png]]

### 문제 3 - Slack 이벤트 중복 요청 문제
Slack은 이벤트에 대한 응답을 3초 안에 받지 못하면 같은 이벤트를 다시 전송하는 메커니즘을 갖추고 있습니다. 이로 인해 가끔 동일한 이벤트가 두 번 도착하는 상황이 발생했습니다. 예를 들어, TIL 챌린지 답글 작성 이벤트를 한 번만 보냈는데도, Slack이 응답이 느리다고 판단해 같은 이벤트를 재전송해버리면 데이터가 이중으로 반영되는 문제가 생길 수 있습니다.
![[img5.png]]

> [!note] 개선 방법: 데이터 중복 처리 예외 강화
> 이 문제를 해결하기 위해 이벤트를 식별할 수 있는 고유한 값(예: 타임스탬프 `ts`)을 사용해 이미 처리한 이벤트인지 확인하는 로직을 추가했습니다. 
>>	- 이벤트 처리 전에 해당 `ts`값을 키로 하는 데이터가 존재하는지 확인  
>>	- 이미 존재한다면 중복 삽입을 막고, 없으면 새로 삽입</br>
> 이러한 예외 처리를 통해 같은 이벤트가 두 번 오더라도 데이터 중복 반영을 방지할 수 있었습니다. 또한 SQS를 도입한 후에는 요청 응답 속도가 개선되면서 Slack이 재전송하는 빈도 자체도 줄어들어, 중복 이벤트 문제 발생 가능성이 더욱 낮아졌습니다.

## 결과 및 성과

- 매주 TIL 챌린지 진행 프로세스 완전 자동화
- 새로운 글 게시 및 좋아요 변동에 대한 실시간 알림 제공  
- 관리자 수동 집계 업무 완전 대체 및 시각화 대시보드 제공  
- AWS 서버리스 아키텍처 경험 및 Slack API 이벤트 처리 노하우 축적

---
### 🔗 Link
- [[content/index|Home]]
- 정리 문서
	- [[서버리스 아키텍처 선정 배경]]
	- [[문제점과 개선한점]]
	- [[Slack Api 이벤트 처리]]